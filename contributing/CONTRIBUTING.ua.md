
### Технічний стек та деяка історія

Тут ми маємо огляд інструментарію та часу виконання цього проекту

Для всього проекту ми маємо

- [Node.js >=18.17.0](https://nodejs.org/). Базове середовище основних бібліотек.
- [Electron 27](https://electron.atom.io). Власне середовище виконання запуску.
- [pnpm](https://pnpm.io/). Використовується для керування пакунками монорепо.
- [TypeScript](https://www.typescriptlang.org/). Весь проект використовує якомога більше TypeScript.

Для основного процесу (Electron) ми маємо

- [esbuild](https://esbuild.github.io/). Ми використовуємо esbuild для побудови TypeScript нашого головного процесу.

Для рендерингової частини, яка є чистим фронтендом

- [Vue] (https://vuejs.org). Використовується для побудови користувацьких інтерфейсів.
- [Vite](https://vitejs.dev/). Використовується як наша система збірки.
- [Vuetify] (https://vuetifyjs.com/). Використовується як бібліотека компонентів.
- [Windi CSS](https://windicss.org/). Використовується для інструментів CSS.
- [Vue Composition API](https://github.com/vuejs/composition-api). Міст для композиційного API для Vue 2. Після оновлення Vuetify до Vue 3, Vue буде оновлено і це буде видалено.

### Структура проекту

![diagram](/assets/diagram.svg)

- xmcl
  - Пов'язане git-репозиторій [launcher-core](https://github.com/voxelum/minecraft-launcher-core-node) є підмодулем git у цьому проекті.
  - Реалізує основну логіку встановлення та запуску Minecraft, а також експонує її у вигляді бібліотеки.
- xmcl-electron-app
  - Використовує Electron для реалізації часу виконання.
  - Це безпосередньо залежить від xmcl-runtime.
  - Неявно залежить від xmcl-keystone-ui (тимчасово, може бути вилучено пізніше?)
- xmcl-keystone-ui
  - Основний інтерфейс запуску за замовчуванням.
  - На 100% сумісний з браузерами. У цьому проекті не задіяно Electron API.
- xmcl-runtime
  - Основна реалізація архітектури панелі запуску. Залежить лише від Node.js і не потребує середовища виконання Electron.
- xmcl-runtime-api
  - Це спільний код та API для виконання XMCL. Він може бути використаний для програми рендерингу (на стороні браузера)


### Концепція/структура

Запускник складається з «сервер/клієнт» або «головний/рендерер». Вони взаємодіють один з одним за допомогою [ipcMain](https://electronjs.org/docs/api/ipc-main) та [ipcRenderer](https://electronjs.org/docs/api/ipc-renderer) від Electron.

Main - це «бекенд» лаунчера. Він керує вікнами і всіма постійними даними/станом програми. Він керує станом за допомогою [Vuex](https://vuex.vuejs.org/). Як тільки стан/дані буде змінено за допомогою [Vuex commit](https://vuex.vuejs.org/guide/mutations.html), він надішле ipc-повідомлення, що містить інформацію про мутацію [mutation info]((https://vuex.vuejs.org/guide/mutations.html)) усьому рендеру. Водночас буде запущено дію збереження зміненого модуля, щоб записати зміни на диск.

Рендерер - це просто (а) браузер, який взаємодіє з main. Він підтримує копію сховища. (Я можу бути повною копією, або частковою копією) Вхідні дані користувача викликають [action](https://vuex.vuejs.org/guide/actions.html) або [commit](https://vuex.vuejs.org/guide/mutations.html), і вони будуть синхронізовані з основним. Це не вимагає ніяких додаткових дій від розробника. Локальний комміт і дія будуть автоматично відправлені на основну сторінку. Розробник може працювати з рендером як зі звичайним vue-додатком.

### Рекомендований до прочитання код інструкції

Якщо вас цікавить конкретна логіка сторінок, ви можете перейти до `xmcl-keystone-ui/src/windows/main/views`. Файли `.vue` у цій теці є основним компонентом, що використовується у програмі запуску. Префікс файлу - це домен інтерфейсу користувача.

Подивіться кілька прикладів:

1. `AppSideBar.vue` - це компонент бічної панелі, а `AppSideBarInstanceItem.vue` - це компонент, який використовується у `AppSideBar.vue`, що представляє екземпляр.
2. `Curseforge.vue` - це компонент сторінки CurseForge, а `CurseforgeCategories.vue` - це картка категорії, що використовується на сторінці `Curseforge.vue`.

Якщо вас цікавить логіка роботи ядра, ви можете перейти до каталогу `xmcl-runtime/services/`. Кожен файл у цьому каталозі представляє службу для певного домену/аспекту логіки запуску. Під час цього процесу вам також слід знати про відповідні файли у каталозі `xmcl-runtime-api/services/`, які описують інтерфейс відповідних сервісів.

Наведемо кілька прикладів:

1. Файл `xmcl-runtime/services/InstanceService.ts` містить реалізацію API для додавання/видалення/оновлення екземплярів. Файл `xmcl-runtime-api/services/InstanceService.ts` містить інтерфейс `InstanceService`.
2. Файл `xmcl-runtime-api/services/InstanceVersionService.ts` містить реалізацію API для перевірки стану версії екземпляра. Вона визначає, яку версію буде використовувати екземпляр, і чи потрібно встановлювати цю версію.
3. Файл `xmcl-runtime/services/InstallService.ts` містить реалізацію API для встановлення Minecraft/Forge/Fabric тощо.
3. `xmcl-runtime/services/LaunchService.ts` містить реалізацію API для запуску екземпляра.

## Сприяти розробці

Наполегливо рекомендуємо використовувати VSCode для відкриття проекту.

### Початок роботи

#### Клонувати

Клонуйте проект з прапором підмодуля `--recurse-submodules`.

```bash
git clone --recurse-submodules https://github.com/Voxelum/x-minecraft-launcher
```

Якщо ви забули додати прапорець `--recurse-submodules`, вам потрібно ініціалізувати та оновити підмодуль git вручну.

```bash
git submodule init
git submodule update
```

#### Встановлення

Встановіть проект за допомогою [pnpm](https://pnpm.io):

```
pnpm install
```

<details>
  <summary> Рішення для повільного встановлення залежностей (наприклад, Electron) у Китаї. </summary>

  Відкрийте git bash і додайте `registry=https://registry.npm.taobao.org electron_mirror=«https://npm.taobao.org/mirrors/electron/»` перед `pnpm i`. Використовуйте дзеркала npm та Electron, надані Ali.

  Останньою командою, яку ви введете, буде

  ```bash
  registry=https://registry.npm.taobao.org electron_mirror="https://npm.taobao.org/mirrors/electron/" pnpm i
  ```
</details>

#### Встановлення змінних оточення

Вам слід встановити `CURSEFORGE_API_KEY`, створивши файл `.env` у каталозі `xmcl-electron-app`. Цей файл `.env` буде додано до файлу `.gitignore`.

**НЕ РОЗГОЛОШУЙТЕ СВІЙ КЛЮЧ CURSEFORGE API***.

#### Запустити лаунчер

Після цього ви можете запустити лаунчер

#### Для VSCode

Перейдіть у розділ `Run and Debug`, використовуйте профіль `Electron: Main (launch)` для запуску електрона. (Гаряча клавіша F5)

#### Для не VSCode

Відкрийте один термінал

```bash
# Start a dev server for UI
npm run dev:renderer
```

Відкрийте інший термінал

``` bash
# Start watching main process code
npm run dev:main
```

#### «Гаряча» зміна коду

Ви внесли зміни до коду і хочете оновити їх у запущеному екземплярі лаунчера.

##### Для процесу в браузері

Vite забезпечує гаряче перезавантаження, він повинен оновлюватися автоматично. Якщо щось пішло не так, ви можете оновити браузер за допомогою `Ctrl+R`.

##### Для процесу Main

Якщо ви використовуєте VSCode для запуску лаунчера, після зміни коду ви можете натиснути кнопку перезавантаження у відладчику VSCode.

Якщо ви не використовуєте VSCode для запуску, то Electron має закритись і перезавантажитись автоматично.

### Знайдено помилку у ядрі панелі запуску

Ядро панелі запуску знаходиться у [окремому проекті](https://github.com/voxelum/minecraft-launcher-core-node), написаному на TypeScript.

Будь ласка, відкрийте проблему там, якщо ви виявите будь-яку проблему, пов'язану з ним.

#### Рекомендований спосіб взаємодії з Vuex

- Створіть новий файл для хука у папці `src/renderer/composables` та експортуйте кидок хука `src/renderer/composables/index.ts`.
  - Загорніть операцію Vuex у ваш хук
- Імпортуйте ваш хук командою `import { yourHook } from '/@/composables'` у вашому Vue-файлі
- Використання хука у файлі Vue без прямого доступу до Vuex

### Налагоджувач VSCode

Проект містить конфіги відладчика VSCode. Ви можете додати точку зупинки на лінії і налагоджувати. Наразі метод відладчика VSCode підтримує налагодження лише на основному процесі.

(Ви можете використовувати Chrome Devtools для процесу рендерингу в будь-якому випадку)

Тепер у нас є два варіанти:

1. Electron: Main (launch)
2. Electron: Main (attach)

Якщо ви використовуєте перший з них для запуску, він автоматично приєднає відладчик до екземпляра.


### Зафіксуйте ваш код

У цьому проекті дотримуються [загальноприйнятих коммітів](https://www.conventionalcommits.org/en/v1.0.0-beta.3/). Коротше кажучи, перший рядок вашого повідомлення про фіксацію має бути:

```
commit type: commit description
```

Існує декілька доступних типів коммітів: `feat`, `fix`, `refactor`, `style`, `docs`, `chore`, `test`.

Довідка з [цієї статті] (https://gist.github.com/joshbuchea/6f47e86d2510bce28f8e7f42ae84c716):

> feat: (нова можливість для користувача, а не нова можливість для сценарію збірки)
>
> fix: (виправлення вади для користувача, а не виправлення для сценарію збірки)
>
> docs: (зміни до документації)
>
> style: (форматування, пропущені крапки з комою тощо; без змін у виробничому коді)
>
> refactor: (рефакторинг виробничого коду, наприклад, перейменування змінної)
>
> test: (додавання відсутніх тестів, рефакторинг тестів; без зміни коду)
>
> chore: (оновлення рутинних завдань і т.д.; без змін у виробничому коді)

**Ваш комміт буде відхилено, якщо ви не дотримуєтесь цих правил.**

### Як збирати

Поточний лаунчер вимагає запуску 2 команд для збірки

По-перше, вам потрібно зібрати код інтерфейсу:

```bash
pnpm build:renderer
```

Якщо код під `xmcl-keystone-ui` не змінився, вам не потрібно збирати його знову.

Після цього ви можете зібрати Electron зі щойно створеним фронтендом:

```bash
pnpm build:all
```

Якщо вам потрібна налагоджувальна збірка, ви можете використати `pnpm build:dir`, яка лише збере результат у каталозі, але не запакує його до іншого формату випуску.